'use strict';

module.exports.queue = function(name, len) {
    this.locks = [];

    this.lock = function (options) {
        let handles = {};
        let _this = this;
        let promise;

        if (this.locks.length >= len)
            handles.promise = Promise.reject(new Error('Queue length exceeded'));
        else if (!this.locks.length) {
            //console.warn('lock');
            handles.promise = Promise.resolve();
            this.locks.push(handles.promise);
        } else {
            //console.warn('wait');
            handles.promise = new Promise(function (resolve, reject) {
                if ((options || {}).timeout)
                    handles.timeout = setTimeout((function () {
                            clearInterval(handles.interval);
                            reject(new Error(`lock timeout: ${name}`));
                            let i = this.locks.indexOf(handles.promise);
                            if (i >= 0)
                                this.locks.splice(i, 1);
                            else
                                throw new Error('Promise item not found');
                        }).bind(_this),
                        options.timeout);
                handles.interval = setInterval((function () {
                    let i = this.locks.indexOf(handles.promise);
                    if (!i) {
                        //console.warn('lock after wait');
                        clearInterval(handles.interval);
                        clearTimeout(handles.timeout);
                        //this.locks.splice(0, 1);
                        resolve(); // переведёт промис в состояние fulfilled
                    } else if (i < 0)
                        throw new Error('Promise item not found');
                }).bind(_this), 0);
            });
            this.locks.push(handles.promise);
        }
        return handles.promise;
    };

    this.unlock = function() {
        //console.warn('unlock');
        this.locks.splice(0, 1);
    };

}
