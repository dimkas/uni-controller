'use strict';

const sqlite = require("node-sqlite.mod/sqlite");

/** @namespace process.mainModule */
const file = 'uc.db';
const db = sqlite.openDatabaseSync(file);
module.exports = db;

module.exports.version = '0.0.1';


db.querySync = querySync;
db.querySync("PRAGMA temp_store = MEMORY;");

module.debug_mem = true && String(process.execArgv[0]).match('--inspect|--debug') !== null;
if(module.debug_mem){
    db.querySync(`ATTACH DATABASE './mem.db' AS mem;`);
    db.querySync(`SELECT name FROM mem.sqlite_master WHERE type IS 'table' AND name NOT LIKE 'sqlite_%'`)
        .forEach(row => db.querySync(`DROP TABLE mem.${row.name}`));
}else
    db.querySync("ATTACH DATABASE ':memory:' AS mem;");

let transactionCount = 0;
db.beginTransaction = function(){
    if(!transactionCount++)
        db.query("BEGIN;");
};
db.commitTransaction = function(){
    if(!transactionCount)
        throw("transaction not active");
    if(!--transactionCount)
        db.query("COMMIT;");
};
db.rollbackTransaction = function(){
    if(!transactionCount)
        throw("transaction not active");
    db.query("ROLLBACK;");
    transactionCount = 0;
};
db.isTransaction = function(){
    return transactionCount > 0;
};

db.date2db = (d)=> Math.trunc(d.getTime() / 1000);
db.date2date = (d)=> new Date(d*1000);

function querySync(query, par) {
    if(query.match(/^BEGIN|^COMMIT|^ROLLBACK/mi))
        throw("do not use SQL transactions");

    let result; //  = db.query(query, par);
    if(query.match(/CREATE|DROP|INSERT|DELETE|UPDATE|ALTER/mi) && query.match(/;/m)){
        try{
            db.beginTransaction();
            result = db.query(query, par);
            db.commitTransaction();
        }catch(err){
            if(db.isTransaction())
                db.rollbackTransaction();
            throw err;
        }
    }else
        result = db.query(query, par);

    return result;
}

function checkTableSchema(schema, table, data){
    // проверим содержит ли описание схемы начальные данные
    if(data.view){
        let q = `CREATE VIEW ${schema}.${table} AS ${data.view}`;
        db.querySync(q);
    }else if(data.schema || !data.data) {
        let table_schema = data.schema || data;
        let table_info = db.querySync(`PRAGMA ${schema}.table_info(${table})`);
        if (!table_info.length) { // таблица не существует
            let q = `CREATE TABLE ${schema}.${table} (\n`;
            for (let key in table_schema)
                q += `[${key}] ${table_schema[key]},\n`;

            q = q.slice(0, -2) + '\n)';
            db.querySync(q);

        } else {
            let columns = {};
            for (let i = 0; i < table_info.length; i++) {
                let column = table_info[i];
                columns[column.name] = column.type;
            }
            let q = '';
            for (let key in table_schema)
                // noinspection JSUnfilteredForInLoop
                if (!columns[key])
                // noinspection JSUnfilteredForInLoop
                    q += `ALTER TABLE ${schema}.${table} ADD [${key}] ${table_schema[key]};\n`;
            if (q)
                db.querySync(q);
        }
    }

    for(let indexType in {'unique index': '', 'index': ''}){
        let index = data[indexType] || {};
        for(let key in index) {
            let index_info = db.querySync(`PRAGMA ${schema}.index_info([${table}.${key}])`);
            if(!index_info.length){
                let columns = '';
                for(let i = 0; i < index[key].length; i++)
                    columns += `, [${index[key][i]}]`;
                columns = columns.slice(2);
                let q = `CREATE ${indexType} ${schema}.[${table}.${key}] ON ${table} (${columns})`;
                db.querySync(q);
            }
        }
    }


    let q = '';
    for(let i = 0; i < (data.data || []).length; i++){
        let columns = '';
        let values = '';
        let row = data.data[i];
        for(let key in row){
            columns += `[${key}], `;
            values += `"${row[key]}", `;
        }
        columns = columns.slice(0, -2);
        values = values.slice(0, -2);
        q += `INSERT OR IGNORE INTO ${schema}.${table} (${columns}) VALUES (${values}); \n`;
    }
    if(q)
        db.querySync(q);

}

db.init = function(initData){
    initData = initData.replaceAll('\n', ' ');
    const data = JSON.parse(initData);
    try {
        db.beginTransaction();

        for (let schema in data)
            for (let table in data[schema])
                checkTableSchema(schema, table, data[schema][table]);

        db.commitTransaction();
    }catch (err){
        if(db.isTransaction())
            db.rollbackTransaction();
        throw(err);
    }
    return module.exports;
};




