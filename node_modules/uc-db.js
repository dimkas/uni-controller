'use strict';

const sqlite = require("node-sqlite.mod/sqlite");

/** @namespace process.mainModule */
const file = 'uc.db';
const db = sqlite.openDatabaseSync(file);
module.exports = db;

module.exports.version = '0.0.1';


db.querySync = querySync;

let transactionCount = 0;
db.beginTransaction = function(){
    if(!transactionCount++)
        db.query("BEGIN;");
};
db.commitTransaction = function(){
    if(!transactionCount)
        throw("transaction not active");
    if(!--transactionCount)
        db.query("COMMIT;");
};
db.rollbackTransaction = function(){
    if(!transactionCount)
        throw("transaction not active");
    db.query("ROLLBACK;");
    transactionCount = 0;
};
db.isTransaction = function(){
    return transactionCount > 0;
};

db.date2db = (d)=> Math.trunc(Date.make(d).getTime() / 1000);


db.querySync(`PRAGMA temp_store = MEMORY;
    PRAGMA foreign_keys=on;`);

module.debug_mem = true && String(process.execArgv[0]).match('--inspect|--debug') !== null;
if(module.debug_mem){
    db.querySync(`ATTACH DATABASE './mem.db' AS mem;`);
    db.querySync(`SELECT name FROM mem.sqlite_master WHERE type IS 'table' AND name NOT LIKE 'sqlite_%'`)
        .forEach(row => db.querySync(`DROP TABLE mem.${row.name}`));
}else
    db.querySync("ATTACH DATABASE ':memory:' AS mem;");



function querySync(query, par) {
    if(query.match(/^BEGIN|^COMMIT|^ROLLBACK/mi))
        throw("do not use SQL transactions");

    let result; //  = db.query(query, par);
    if(query.match(/CREATE|DROP|INSERT|DELETE|UPDATE|ALTER/mi)){// && query.match(/;/m)){
        try{
            db.beginTransaction();
            result = db.query(query, par);
            db.commitTransaction();
        }catch(err){
            if(db.isTransaction())
                db.rollbackTransaction();
            throw err;
        }
    }else
        result = db.query(query, par);

    return result;
}

function buildSqlForCreateTable(schema, table_schema, table, constraint) {
    let sql = `CREATE TABLE ${schema==='main' ? '' : schema + '.'}${table} (\n`;
    for (let key in table_schema)
        sql += `[${key}] ${table_schema[key]},\n`;
    if(constraint)
        sql += constraint.join(',\n') + ')';
    else
        sql = sql.slice(0, -2) + '\n)';
    return sql;
}

module.exports.renameColumns = function (initData, table, renameColumns) {
    initData = initData.replaceAll('\n', ' ');
    const data = JSON.parse(initData);
    try {
        db.beginTransaction();
        let tdata = data.main[table];
        recreateTable('main', table, tdata, renameColumns);

        db.commitTransaction();
    }catch (err){
        if(db.isTransaction())
            db.rollbackTransaction();
        throw(err);
    }
};

function recreateTable(schema, table, newTableData, renameColumns) {
    if(schema !== 'main')
        throw new Error(`Recreate table supported only for db 'main'`);

    console.warn(`Recreate table: ${schema}.${table}`);

    let newTableSchema = newTableData.schema || newTableData;

    let newColumns = {};
    for(let key in newTableSchema)
        newColumns[key.toLowerCase()] = key;

    let columnsListOld = [], columnsListNew = [];
    db.querySync(`PRAGMA table_info(${table})`).forEach(item=>{
        if(newColumns[item.name.toLowerCase()]) {
            columnsListOld.push(item.name);
            columnsListNew.push(newColumns[item.name.toLowerCase()]);
        }else if(renameColumns && renameColumns[item.name]){
            if(newColumns[renameColumns[item.name].toLowerCase()]){
                columnsListOld.push(item.name);
                columnsListNew.push(newColumns[renameColumns[item.name].toLowerCase()]);
            }
        }
    });

    let tempName = `temp.${table}_${Date.now()}`;
    //let newSql1 = buildSqlForCreateTable('temp', newTableSchema, tempName);
    let newSql = buildSqlForCreateTable(schema, newTableSchema, table, newTableData.constraint);

    db.querySync(`PRAGMA foreign_keys=off;`);
    if(columnsListOld.length && db.querySync(`SELECT 1 FROM ${table} LIMIT 1`).length){
        db.querySync(`CREATE TABLE ${tempName} AS SELECT * FROM ${table};
            DROP TABLE ${table};
            ${newSql};
            INSERT INTO ${table}(${columnsListNew.join(', ')})
                SELECT ${columnsListOld.join(', ')} FROM ${tempName};         
            DROP TABLE ${tempName};`);
    }else{
        db.querySync(`DROP TABLE ${table};
            ${newSql};`);
    }
    db.querySync(`PRAGMA foreign_keys=on;`);
}

function checkTableSchema(schema, table, data){
    // проверим содержит ли описание схемы начальные данные
    let table_schema = (data.view || data.schema || data.data || data['index'] || data['unique index'])
        ? data.schema : data;

    if(data.view){
        let q = `CREATE VIEW ${schema}.${table} AS ${data.view}`;
        db.querySync(q);
    }
    if(table_schema) {
        if (!Object.keys(table_schema).length) {
            console.warn(`Delete table: ${schema}.${table}`);
            db.querySync(`DROP TABLE ${schema}.${table}`);
        } else {
            let sql = buildSqlForCreateTable(schema, table_schema, table, data.constraint);

            let table_info = db.querySync(`SELECT sql FROM ${schema}.sqlite_master WHERE type='table' AND name='${table}'`)[0];
            if (!table_info) {
                // нет таблицы, надо создать - выполняем запрос
                if(schema === 'main')
                    console.warn(`Create table: ${schema}.${table}`);
                else
                    console.log(`Create table: ${schema}.${table}`);

                db.querySync(sql);

            } else if (table_info.sql !== sql) {
                if(schema === 'main') {
                    // структура таблицы изменилась, будем переносить данные
                    recreateTable(schema, table, data);
                }else if(table_info.sql !== sql.replace(` ${schema}.`, ' ')){
                    throw new Error(`Recreate table supported only for db 'main'`);
                }
            }
        }
    }

    if(data['index'] || data['unique index']){
        let indexTypes = {'unique index': 'UNIQUE INDEX', 'index': 'INDEX'};
        let indexes = {};
        for(let indexType in indexTypes)
            for(let key in (data[indexType] || {}))
                indexes[key] = indexType;

        for(let name in indexes){
            let indexType = indexes[name];
            let index = data[indexType][name];
            if(index.length) {
                let columns = index.map(item => `[${item}]`).join(', ');
                let sql = `CREATE ${indexType.toUpperCase()} ${schema === 'main' ? '' : schema + '.'}[${table}.${name}] ON ${table} (${columns})`;
                let index_info = db.querySync(`SELECT sql FROM ${schema}.sqlite_master WHERE type='index' AND name='${table}.${name}'`)[0];
                if (index_info && index_info.sql !== sql) {
                    if (schema === 'main') {
                        console.warn(`Recreate index: ${schema}.[${row.name}]`);
                        db.querySync(`DROP INDEX [${table}.${name}];
                            ${sql};`);
                    }else if(index_info.sql !== sql.replace(` ${schema}.`, ' ')){
                        throw new Error(`Recreate index supported only for db 'main'`);
                    }
                }else if(!index_info){
                    if(schema === 'main')
                        console.warn(`Create index: [${table}.${name}]`);
                    else
                        console.log(`Create index: ${schema}.[${table}.${name}]`);
                    db.querySync(`${sql};`);
                }
            }else if(db.querySync(`SELECT name, sql FROM ${schema}.sqlite_master WHERE type='index' AND name = '${table}.${name}'`).length){
                console.warn(`Delete index: ${schema}.[${row.name}]`);
                db.querySync(`DROP INDEX ${schema}.[${row.name}]`);
            }
        }
    }

    if(data.data){
        let q = '';
        data.data.forEach(row => {
            let columns = [], values = [];
            for(let key in row)
                columns.push(`[${key}]`), values.push(`"${row[key]}"`);

            q += `INSERT OR IGNORE INTO ${schema}.${table} (${columns.join(', ')}) VALUES (${values.join(', ')}); \n`;
        });
        if(q)
            db.querySync(q);
    }
}

db.init = function(initData){
    initData = initData.replaceAll('\n', ' ');
    const data = JSON.parse(initData);
    try {
        db.beginTransaction();

        for (let schema in data)
            for (let table in data[schema])
                checkTableSchema(schema, table, data[schema][table]);

        db.commitTransaction();
    }catch (err){
        if(db.isTransaction())
            db.rollbackTransaction();
        throw(err);
    }
    return module.exports;
};




