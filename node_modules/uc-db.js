'use strict';

const sqlite = require("node-sqlite.mod/sqlite");

/** @namespace process.mainModule */
const file = 'uc.db';
const db = sqlite.openDatabaseSync(file);
module.exports = db;

module.exports.version = '0.0.1';


db.querySync = querySync;
db.querySync("PRAGMA temp_store = MEMORY;");

module.debug_mem = true && String(process.execArgv[0]).match('--inspect|--debug') !== null;
if(module.debug_mem){
    db.querySync(`ATTACH DATABASE './mem.db' AS mem;`);
    db.querySync(`SELECT name FROM mem.sqlite_master WHERE type IS 'table' AND name NOT LIKE 'sqlite_%'`)
        .forEach(row => db.querySync(`DROP TABLE mem.${row.name}`));
}else
    db.querySync("ATTACH DATABASE ':memory:' AS mem;");

let transactionCount = 0;
db.beginTransaction = function(){
    if(!transactionCount++)
        db.query("BEGIN;");
};
db.commitTransaction = function(){
    if(!transactionCount)
        throw("transaction not active");
    if(!--transactionCount)
        db.query("COMMIT;");
};
db.rollbackTransaction = function(){
    if(!transactionCount)
        throw("transaction not active");
    db.query("ROLLBACK;");
    transactionCount = 0;
};
db.isTransaction = function(){
    return transactionCount > 0;
};

db.date2db = (d)=> Math.trunc(Date.make(d).getTime() / 1000);


function querySync(query, par) {
    if(query.match(/^BEGIN|^COMMIT|^ROLLBACK/mi))
        throw("do not use SQL transactions");

    let result; //  = db.query(query, par);
    if(query.match(/CREATE|DROP|INSERT|DELETE|UPDATE|ALTER/mi) && query.match(/;/m)){
        try{
            db.beginTransaction();
            result = db.query(query, par);
            db.commitTransaction();
        }catch(err){
            if(db.isTransaction())
                db.rollbackTransaction();
            throw err;
        }
    }else
        result = db.query(query, par);

    return result;
}

function buildSqlForCreateTable(schema, table_schema, table) {
    let sql = `CREATE TABLE ${schema==='main' ? '' : schema + '.'}${table} (\n`;
    for (let key in table_schema)
        sql += `[${key}] ${table_schema[key]},\n`;
    sql = sql.slice(0, -2) + '\n)';
    return sql;
}

function recreateTable(schema, table, newTableSchema) {
    if(schema !== 'main')
        throw new Error(`Recreate table supported only for db 'main'`);

    console.warn(`Recreate table: ${schema}.${table}`);

    let newColumns = {}, newColumnsArr = [];
    for(let key in newTableSchema) {
        newColumns[key.toLowerCase()] = key;
        newColumnsArr.push(key);
    }


    let columnsList = [];
    db.querySync(`PRAGMA table_info(${table})`).forEach(item=>{
        if(newColumns[item.name.toLowerCase()])
            columnsList.push(newColumns[item.name.toLowerCase()]);
    });

    let tempName = `${table}_${Date.now()}`;
    let newSql1 = buildSqlForCreateTable(schema, newTableSchema, tempName);
    let newSql2 = buildSqlForCreateTable(schema, newTableSchema, table);

    db.querySync(`PRAGMA foreign_keys=off;
        ${newSql1};` + (columnsList.length ?
        `INSERT INTO ${tempName}(${columnsList.join(', ')})
            SELECT ${columnsList.join(', ')} FROM ${table};` : '') + `
        DROP TABLE ${table};
        ${newSql2};
        INSERT INTO ${table}(${newColumnsArr.join(', ')})
            SELECT ${newColumnsArr.join(', ')} FROM ${tempName};         
        DROP TABLE ${tempName};
        PRAGMA foreign_keys=on;`);

}

function checkTableSchema(schema, table, data){
    // проверим содержит ли описание схемы начальные данные
    if(data.view){
        let q = `CREATE VIEW ${schema}.${table} AS ${data.view}`;
        db.querySync(q);
    }else if(data.schema || !data.data) {

        let table_schema = data.schema || data;

        if(!Object.keys(table_schema).length){
            console.warn(`Delete table: ${schema}.${table}`);
            db.querySync(`DROP TABLE ${schema}.${table}`);
        }else{
            let sql = buildSqlForCreateTable(schema, table_schema, table);
            // let sql = `CREATE TABLE ${schema==='main' ? '' : schema + '.'}${table} (\n`;
            // for (let key in table_schema)
            //     sql += `[${key}] ${table_schema[key]},\n`;
            // sql = sql.slice(0, -2) + '\n)';

            let table_info = db.querySync(`SELECT sql FROM ${schema}.sqlite_master WHERE type='table' AND name='${table}'`)[0];
            if(!table_info) {
                // нет таблицы, надо создать - выполняем запрос
                db.querySync(sql);

            }else if(table_info.sql !== sql){
                // структура таблицы изменилась, будем переносить данные
                recreateTable(schema, table, table_schema);
            }

            let indexTypes = {'unique index': 'UNIQUE INDEX', 'index': 'INDEX'};
            let indexes = {};
            for(let indexType in indexTypes)
                for(let key in (data[indexType] || {}))
                    indexes[key] = indexType;

            db.querySync(`SELECT name FROM ${schema}.sqlite_master WHERE type='index' AND name LIKE '${table}.%'`)
                .forEach(row=>{
                    if(!indexes[row.name.split('.')[1]]){
                        console.warn(`Delete index: ${schema}.[${row.name}]`);
                        db.querySync(`DROP INDEX ${schema}.[${row.name}]`);
                    }
                });

            for(let name in indexes){
                let indexType = indexes[name];
                let index = data[indexType][name];
                let columns = index.map(item=>`[${item}]`).join(', ');
                let sql = `CREATE ${indexType.toUpperCase()} ${schema==='main' ? '' : schema + '.'}[${table}.${name}] ON ${table} (${columns})`;
                let index_info = db.querySync(`SELECT sql FROM ${schema}.sqlite_master WHERE type='index' AND name='${table}.${name}'`)[0];
                if(index_info && index_info.sql !== sql) {
                    if (schema !== 'main')
                        throw new Error(`Recreate index supported only for db 'main'`);
                    db.querySync(`DROP INDEX [${table}.${name}];
                        ${sql};`);
                }
            }
        }



        /*


        let table_info = db.querySync(`PRAGMA ${schema}.table_info(${table})`);
        if (!table_info.length) { // таблица не существует
            db.querySync(q);

        } else {
            let columns = {};
            for (let i = 0; i < table_info.length; i++) {
                let column = table_info[i];
                columns[column.name] = column.type;
            }
            let q = '';
            for (let key in table_schema)
                // noinspection JSUnfilteredForInLoop
                if (!columns[key])
                // noinspection JSUnfilteredForInLoop
                    q += `ALTER TABLE ${schema}.${table} ADD [${key}] ${table_schema[key]};\n`;
            if (q)
                db.querySync(q);
        }
        */


    }





    let q = '';
    for(let i = 0; i < (data.data || []).length; i++){
        let columns = '';
        let values = '';
        let row = data.data[i];
        for(let key in row){
            columns += `[${key}], `;
            values += `"${row[key]}", `;
        }
        columns = columns.slice(0, -2);
        values = values.slice(0, -2);
        q += `INSERT OR IGNORE INTO ${schema}.${table} (${columns}) VALUES (${values}); \n`;
    }
    if(q)
        db.querySync(q);

}

db.init = function(initData){
    initData = initData.replaceAll('\n', ' ');
    const data = JSON.parse(initData);
    try {
        db.beginTransaction();

        for (let schema in data)
            for (let table in data[schema])
                checkTableSchema(schema, table, data[schema][table]);

        db.commitTransaction();
    }catch (err){
        if(db.isTransaction())
            db.rollbackTransaction();
        throw(err);
    }
    return module.exports;
};




