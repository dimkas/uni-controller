'use strict';

const utils = require("uc-utils");
const db = require("uc-db").init(getDbInitData());
const wscli = require("uc-wscli");
const util = require("util");

module.exports.version = '0.0.1';

function EventEmitterClass() {
    this.events = {
        SensorDataReceived: 'sensor-data-received'
    };
}
util.inherits(EventEmitterClass, require("events"));
const EventEmitter = new EventEmitterClass();
//module.exports.on = events.on.bind(events);
const sensors = module.exports;

module.exports.onSensorDataReceived = EventEmitter.on.bind(EventEmitter, EventEmitter.events.SensorDataReceived);


wscli.context.add('sensor');

wscli.commands.add({Sensor: Number}, (arg)=> {
        sensors.checkRangeSensorID(arg, 0);
        wscli.context.current = wscli.context.sensor;
        wscli.current.sensor = arg;
        return true;
    },
    'Set sensor as current.'
);


wscli.commands.add({SetName: String}, (arg) =>{
        if(wscli.context.current === wscli.context.sensor){
            sensors.checkRangeSensorID(wscli.current.sensor);
            if(arg) {
                let q = `REPLACE INTO SensorsNames (SensorID, Name) VALUES ($ID, $Name)`;
                db.querySync(q, {$ID: wscli.current.sensor, $Name: arg});
            } else {
                db.querySync('DELETE FROM SensorsNames WHERE SensorID = $ID', {$ID: wscli.current.sensor});
            }
            wscli.sendData(`#Sensor:0x${Number(wscli.current.sensor).toHex()},Name:${wscli.data.toString(arg)}`);
            return true;
        }
    },
    'Set sensor name.');

wscli.commands.add({GetName: null}, (arg)=>{
        if(wscli.context.current === wscli.context.sensor){
            sensors.checkRangeSensorID(wscli.current.sensor, 0);
            let res = false;
            let rows = db.querySync("SELECT SensorID, Name FROM SensorsNames WHERE SensorID = $ID OR $ID = 0", {$ID: wscli.current.sensor});
            rows.forEach(function (row) {
                wscli.sendData(`#Sensor:0x${Number(row.SensorID).toHex()},Name:${wscli.data.toString(row.Name)}`);
                res = true;
            });
            //if(!res)
            //    throw("Sensor name not defined");
            return true;
        }
    },
    'Get sensors name.');

wscli.commands.add({GetData: String}, (arg)=>{
        if(wscli.context.current === wscli.context.sensor) {
            sensors.checkRangeSensorID(wscli.current.sensor, 0);
            let arg_arr = arg.split('>');

            // noinspection JSBitwiseOperatorUsage
            let timeFilter = (arg_arr[1] ? db.date2db(wscli.data.fromString(arg_arr[1], Date)) : 0);

            let rows = db.querySync("SELECT SensorID, Type, TimeLabel FROM mem.SensorsData WHERE (SensorID = $ID OR $ID = 0) AND ReceiveTime > $ReceiveTime", {
                $ID: wscli.current.sensor,
                $ReceiveTime: timeFilter
            });
            rows.forEach(function (row) {
                let data = '';
                let TimeLabel = new Date(row.TimeLabel * 1000);
                /** @namespace row.Type */
                data += `#Sensor:0x${Number(row.SensorID).toHex()},Type:${row.Type},TimeLabel:${utils.DateToShortXMLString(TimeLabel)}`;
                data += ',Data:';
                let params = {};
                let rows_param = db.querySync("SELECT Param, Value FROM mem.SensorsParams WHERE SensorID = $ID", {$ID: row.SensorID});
                rows_param.forEach(function (row_param) {
                    /** @namespace row_param.Param */
                    /** @namespace row_param.Value */
                    params[row_param.Param] = row_param.Value;
                });
                data += wscli.data.toString(params);
                wscli.sendClientData(data);
            });
            return true;
        }
    },
    'Get sensor data.');


module.exports.updateSensorData = function(params){
    let sensor = {};
    let kebab_params = {};
    let paramCount = 0;
    for(let key in params){
        let lckey = key.toLowerCase();
        switch (lckey){
            case 'id': sensor.ID = params[key]; break;
            case 'type': sensor.Type = params[key]; break;
            case 'timelabel': sensor.TimeLabel = params[key]; break;
            default:
                kebab_params[key.toKebab()] = params[key], paramCount++;
        }
    }

    if(!sensor.ID) throw new Error('Sensor ID is empty');
    else if(!sensor.Type) throw new Error('Sensor Type is empty');
    else if(!sensor.TimeLabel) throw new Error('Sensor data Timelabel is empty');
    else if(!paramCount) throw new Error('Sensor data is empty');

    const qp = {$ID: sensor.ID, $Type: sensor.Type, $TimeLabel: db.date2db(sensor.TimeLabel)};
    let q = `SELECT SensorsData.SensorID,
                ($TimeLabel - TimeLabel) as dif,
                $TimeLabel,
                TimeLabel
            FROM mem.SensorsData as SensorsData, SensorsSettings as SensorsSettings
            WHERE SensorsData.SensorID = $ID
                AND ($TimeLabel - TimeLabel) <= SensorsSettings.MaxTimeDivergence`;
    let rows = db.querySync(q, qp);
    if(rows.length){
        //console.log(`Ignore:`);
        //console.log(rows[0]);
        return;
    }else {
        //console.log(qp);
    }

    qp.$ReceiveTime = db.date2db(new Date());
    q = `DELETE FROM mem.SensorsParams WHERE SensorID = $ID;
        REPLACE INTO mem.SensorsData (SensorID, Type, TimeLabel, ReceiveTime) VALUES ($ID, $Type, $TimeLabel, $ReceiveTime);\n`;

    for (let key in kebab_params) {
        // noinspection JSUnfilteredForInLoop
        q += `INSERT INTO mem.SensorsParams (SensorID, Param, Value) VALUES ($ID, '${key}', ${kebab_params[key]});\n`;
    }
    db.querySync(q, qp);

    EventEmitter.emit(EventEmitter.events.SensorDataReceived,
        {id: sensor.ID, type: sensor.Type, timelabel: new Date(sensor.TimeLabel), params: kebab_params});

};



module.exports.checkRangeSensorID = (arg, allowVal) =>{
    if(allowVal === undefined)
        return wscli.checkInRange(arg, 1, 0xFFFF, 'Sensor');
    else
        return wscli.checkInRange(arg, [[allowVal, allowVal], [1, 0xFFFF]], 'Sensor');

};



function getDbInitData() {

    return `{
          "main": {
            "SensorsNames": {
              "SensorID": "INTEGER PRIMARY KEY NOT NULL",
              "Name": "CHAR(32) NOT NULL ON CONFLICT REPLACE DEFAULT ''"
            },
            "SensorsSettings": {
              "schema": {
                "MaxTimeDivergence": "INTEGER"
              },
              "data": [
                {"RowID": 1, "MaxTimeDivergence": 2}
              ]
            }
          },
          "mem":{
            "SensorsData": {
              "SensorID": "INTEGER PRIMARY KEY NOT NULL",
              "Type": "CHAR(16) NOT NULL",
              "TimeLabel": "INTEGER NOT NULL",
              "ReceiveTime": "INTEGER NOT NULL"
            },
            "SensorsParams": {
              "schema": {
                  "SensorID": "INTEGER NOT NULL CONSTRAINT [SensorID] REFERENCES [SensorsData]([SensorID]) ON DELETE CASCADE",
                  "Param": "CHAR(16) NOT NULL",
                  "Value": "INTEGER NOT NULL"
              },
              "unique index": {
                "SensorIdParam": ["SensorID", "Param"]
              }
            }
          }
        }`;
}
